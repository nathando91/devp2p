import { Multiaddr } from "@multiformats/multiaddr";
import { KeyType, PeerId, PrivateKey } from "@libp2p/interface";
import { ENRKey, ENRValue, SequenceNumber, NodeId } from "./types.js";
/** ENR identity scheme */
export declare enum IDScheme {
    v4 = "v4"
}
/** Raw data included in an ENR */
export type ENRData = {
    kvs: ReadonlyMap<ENRKey, ENRValue>;
    seq: SequenceNumber;
    signature: Uint8Array;
};
/** Raw data included in a read+write ENR */
export type SignableENRData = {
    kvs: ReadonlyMap<ENRKey, ENRValue>;
    seq: SequenceNumber;
    privateKey: Uint8Array;
};
export declare function id(kvs: ReadonlyMap<ENRKey, ENRValue>): IDScheme;
export declare function nodeId(id: IDScheme, publicKey: Uint8Array): NodeId;
export declare function publicKey(id: IDScheme, kvs: ReadonlyMap<ENRKey, ENRValue>): Uint8Array;
export declare function keyType(id: IDScheme): KeyType;
export declare function verify(id: IDScheme, data: Uint8Array, publicKey: Uint8Array, signature: Uint8Array): boolean;
export declare function sign(id: IDScheme, data: Uint8Array, privateKey: Uint8Array): Uint8Array;
export declare function encodeToValues(kvs: ReadonlyMap<ENRKey, ENRValue>, seq: SequenceNumber, signature?: Uint8Array): (ENRKey | ENRValue | number)[];
export declare function encode(kvs: ReadonlyMap<ENRKey, ENRValue>, seq: SequenceNumber, signature: Uint8Array): Uint8Array;
export declare function decodeFromValues(decoded: Uint8Array[]): ENRData;
export declare function decode(encoded: Uint8Array): ENRData;
export declare function txtToBuf(encoded: string): Uint8Array;
export declare function decodeTxt(encoded: string): ENRData;
/** Protocols automagically supported by this library */
export type Protocol = "udp" | "tcp" | "quic" | "udp4" | "udp6" | "tcp4" | "tcp6" | "quic4" | "quic6";
export declare function getIPValue(kvs: ReadonlyMap<ENRKey, ENRValue>, key: string, multifmtStr: string): string | undefined;
export declare function getProtocolValue(kvs: ReadonlyMap<ENRKey, ENRValue>, key: string): number | undefined;
export declare function portToBuf(port: number): Uint8Array;
export declare function parseLocationMultiaddr(ma: Multiaddr): {
    family: 4 | 6;
    ip: Uint8Array;
    protoName: "udp" | "tcp" | "quic";
    protoVal: Uint8Array;
};
export declare abstract class BaseENR {
    /** Raw enr key-values */
    abstract kvs: ReadonlyMap<ENRKey, ENRValue>;
    /** Sequence number */
    abstract seq: SequenceNumber;
    abstract signature: Uint8Array;
    /** Node identifier */
    abstract nodeId: NodeId;
    abstract publicKey: Uint8Array;
    /** enr identity scheme */
    get id(): IDScheme;
    get keypairType(): KeyType;
    get peerId(): PeerId;
    get ip(): string | undefined;
    get tcp(): number | undefined;
    get udp(): number | undefined;
    get quic(): number | undefined;
    get ip6(): string | undefined;
    get tcp6(): number | undefined;
    get udp6(): number | undefined;
    get quic6(): number | undefined;
    getLocationMultiaddr(protocol: Protocol): Multiaddr | undefined;
    getFullMultiaddr(protocol: Protocol): Promise<Multiaddr | undefined>;
    abstract encodeToValues(): (ENRKey | ENRValue | number)[];
    abstract encode(): Uint8Array;
    encodeTxt(): string;
}
/**
 * Ethereum Name Record
 *
 * https://eips.ethereum.org/EIPS/eip-778
 *
 * `ENR` is used to read serialized ENRs and may not be modified once created.
 */
export declare class ENR extends BaseENR {
    kvs: ReadonlyMap<ENRKey, ENRValue>;
    seq: SequenceNumber;
    signature: Uint8Array;
    nodeId: string;
    private encoded?;
    constructor(kvs: ReadonlyMap<ENRKey, ENRValue> | Record<ENRKey, ENRValue>, seq: SequenceNumber, signature: Uint8Array, encoded?: Uint8Array);
    static fromObject(obj: ENRData): ENR;
    static decodeFromValues(encoded: Uint8Array[]): ENR;
    static decode(encoded: Uint8Array): ENR;
    static decodeTxt(encoded: string): ENR;
    get publicKey(): Uint8Array;
    toObject(): ENRData;
    encodeToValues(): Uint8Array[];
    encode(): Uint8Array;
}
/**
 * Ethereum Name Record
 *
 * https://eips.ethereum.org/EIPS/eip-778
 *
 * `SignableENR` is used to create and update ENRs.
 */
export declare class SignableENR extends BaseENR {
    kvs: ReadonlyMap<ENRKey, ENRValue>;
    seq: SequenceNumber;
    nodeId: NodeId;
    publicKey: Uint8Array;
    privateKey: Uint8Array;
    private _signature?;
    constructor(kvs: ReadonlyMap<string, Uint8Array> | Record<string, Uint8Array> | undefined, seq: bigint | undefined, privateKey: Uint8Array, signature?: Uint8Array);
    static fromObject(obj: SignableENRData): SignableENR;
    static createV4(privateKey: Uint8Array, kvs?: Record<ENRKey, ENRValue>): SignableENR;
    static createFromPrivateKey(privateKey: PrivateKey, kvs?: Record<ENRKey, ENRValue>): SignableENR;
    static decodeFromValues(encoded: Uint8Array[], privateKey: Uint8Array): SignableENR;
    static decode(encoded: Uint8Array, privateKey: Uint8Array): SignableENR;
    static decodeTxt(encoded: string, privateKey: Uint8Array): SignableENR;
    get signature(): Uint8Array;
    set(k: ENRKey, v: ENRValue): void;
    delete(k: ENRKey): boolean;
    get peerId(): PeerId;
    get ip(): string | undefined;
    set ip(ip: string | undefined);
    get tcp(): number | undefined;
    set tcp(port: number | undefined);
    get udp(): number | undefined;
    set udp(port: number | undefined);
    get quic(): number | undefined;
    set quic(port: number | undefined);
    get ip6(): string | undefined;
    set ip6(ip: string | undefined);
    get tcp6(): number | undefined;
    set tcp6(port: number | undefined);
    get udp6(): number | undefined;
    set udp6(port: number | undefined);
    get quic6(): number | undefined;
    set quic6(port: number | undefined);
    setLocationMultiaddr(multiaddr: Multiaddr): void;
    toObject(): SignableENRData;
    encodeToValues(): (string | number | Uint8Array)[];
    encode(): Uint8Array;
    toENR(): ENR;
}
//# sourceMappingURL=enr.d.ts.map