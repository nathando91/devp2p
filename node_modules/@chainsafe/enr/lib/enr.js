import { multiaddr, protocols } from "@multiformats/multiaddr";
import * as RLP from "rlp";
import { convertToString, convertToBytes } from "@multiformats/multiaddr/convert";
import { encode as varintEncode } from "uint8-varint";
import { ERR_INVALID_ID, MAX_RECORD_SIZE } from "./constants.js";
import { createPeerIdFromPublicKey } from "./peerId.js";
import { fromBase64url, toBase64url, toBigInt, toNewUint8Array } from "./util.js";
import { getV4Crypto } from "./crypto.js";
import { compare, fromString, toString } from "uint8arrays";
/** ENR identity scheme */
export var IDScheme;
(function (IDScheme) {
    IDScheme["v4"] = "v4";
})(IDScheme || (IDScheme = {}));
export function id(kvs) {
    const idBuf = kvs.get("id");
    if (!idBuf)
        throw new Error("id not found");
    const id = toString(idBuf, "utf8");
    if (IDScheme[id] == null) {
        throw new Error("Unknown enr id scheme: " + id);
    }
    return id;
}
export function nodeId(id, publicKey) {
    switch (id) {
        case IDScheme.v4:
            return getV4Crypto().nodeId(publicKey);
        default:
            throw new Error(ERR_INVALID_ID);
    }
}
export function publicKey(id, kvs) {
    switch (id) {
        case IDScheme.v4: {
            const pubkey = kvs.get("secp256k1");
            if (!pubkey) {
                throw new Error("Pubkey doesn't exist");
            }
            return pubkey;
        }
        default:
            throw new Error(ERR_INVALID_ID);
    }
}
export function keyType(id) {
    switch (id) {
        case "v4":
            return "secp256k1";
        default:
            throw new Error(ERR_INVALID_ID);
    }
}
export function verify(id, data, publicKey, signature) {
    switch (id) {
        case IDScheme.v4:
            return getV4Crypto().verify(publicKey, data, signature);
        default:
            throw new Error(ERR_INVALID_ID);
    }
}
export function sign(id, data, privateKey) {
    switch (id) {
        case IDScheme.v4:
            return getV4Crypto().sign(privateKey, data);
        default:
            throw new Error(ERR_INVALID_ID);
    }
}
export function encodeToValues(kvs, seq, signature) {
    // sort keys and flatten into [k, v, k, v, ...]
    const content = Array.from(kvs.keys())
        .sort((a, b) => a.localeCompare(b))
        .map((k) => [k, kvs.get(k)])
        .flat();
    content.unshift(Number(seq));
    if (signature) {
        content.unshift(signature);
    }
    return content;
}
export function encode(kvs, seq, signature) {
    const encoded = RLP.encode(encodeToValues(kvs, seq, signature));
    if (encoded.length >= MAX_RECORD_SIZE) {
        throw new Error("ENR must be less than 300 bytes");
    }
    return encoded;
}
export function decodeFromValues(decoded) {
    if (!Array.isArray(decoded)) {
        throw new Error("Decoded ENR must be an array");
    }
    if (decoded.length % 2 !== 0) {
        throw new Error("Decoded ENR must have an even number of elements");
    }
    const [signature, seq] = decoded;
    if (!signature || Array.isArray(signature)) {
        throw new Error("Decoded ENR invalid signature: must be a byte array");
    }
    if (!seq || Array.isArray(seq)) {
        throw new Error("Decoded ENR invalid sequence number: must be a byte array");
    }
    const kvs = new Map();
    const signed = [seq];
    for (let i = 2; i < decoded.length; i += 2) {
        const k = decoded[i];
        const v = decoded[i + 1];
        kvs.set(k.toString(), v);
        signed.push(k, v);
    }
    const _id = id(kvs);
    if (!verify(_id, RLP.encode(signed), publicKey(_id, kvs), signature)) {
        throw new Error("Unable to verify enr signature");
    }
    return {
        kvs,
        seq: toBigInt(seq),
        signature,
    };
}
export function decode(encoded) {
    return decodeFromValues(RLP.decode(encoded));
}
export function txtToBuf(encoded) {
    if (!encoded.startsWith("enr:")) {
        throw new Error("string encoded ENR must start with 'enr:'");
    }
    return fromBase64url(encoded.slice(4));
}
export function decodeTxt(encoded) {
    return decode(txtToBuf(encoded));
}
export function getIPValue(kvs, key, multifmtStr) {
    const raw = kvs.get(key);
    if (raw) {
        return convertToString(multifmtStr, toNewUint8Array(raw));
    }
    else {
        return undefined;
    }
}
export function getProtocolValue(kvs, key) {
    const raw = kvs.get(key);
    if (raw) {
        if (raw.length < 2) {
            throw new Error("Encoded protocol length should be 2");
        }
        return (raw[0] << 8) + raw[1];
    }
    else {
        return undefined;
    }
}
export function portToBuf(port) {
    const buf = new Uint8Array(2);
    buf[0] = port >> 8;
    buf[1] = port;
    return buf;
}
export function parseLocationMultiaddr(ma) {
    const protoNames = ma.protoNames();
    const tuples = ma.tuples();
    let family;
    let protoName;
    if (protoNames[0] === "ip4") {
        family = 4;
    }
    else if (protoNames[0] === "ip6") {
        family = 6;
    }
    else {
        throw new Error("Invalid multiaddr: must start with ip4 or ip6");
    }
    if (tuples[0][1] == null) {
        throw new Error("Invalid multiaddr: ip address is missing");
    }
    const ip = tuples[0][1];
    if (protoNames[1] === "udp") {
        protoName = "udp";
    }
    else if (protoNames[1] === "tcp") {
        protoName = "tcp";
    }
    else {
        throw new Error("Invalid multiaddr: must have udp or tcp protocol");
    }
    if (tuples[1][1] == null) {
        throw new Error("Invalid multiaddr: udp or tcp port is missing");
    }
    const protoVal = tuples[1][1];
    if (protoNames.length === 3) {
        if (protoNames[2] === "quic-v1") {
            if (protoName !== "udp") {
                throw new Error("Invalid multiaddr: quic protocol must be used with udp");
            }
            protoName = "quic";
        }
        else {
            throw new Error("Invalid multiaddr: unknown protocol");
        }
    }
    else if (protoNames.length > 2) {
        throw new Error("Invalid multiaddr: unknown protocol");
    }
    return { family, ip, protoName, protoVal };
}
// Classes
export class BaseENR {
    /** enr identity scheme */
    get id() {
        return id(this.kvs);
    }
    get keypairType() {
        return keyType(this.id);
    }
    get peerId() {
        return createPeerIdFromPublicKey(this.keypairType, this.publicKey);
    }
    // Network methods
    get ip() {
        return getIPValue(this.kvs, "ip", "ip4");
    }
    get tcp() {
        return getProtocolValue(this.kvs, "tcp");
    }
    get udp() {
        return getProtocolValue(this.kvs, "udp");
    }
    get quic() {
        return getProtocolValue(this.kvs, "quic");
    }
    get ip6() {
        return getIPValue(this.kvs, "ip6", "ip6");
    }
    get tcp6() {
        return getProtocolValue(this.kvs, "tcp6");
    }
    get udp6() {
        return getProtocolValue(this.kvs, "udp6");
    }
    get quic6() {
        return getProtocolValue(this.kvs, "quic6");
    }
    getLocationMultiaddr(protocol) {
        if (protocol === "udp") {
            return this.getLocationMultiaddr("udp4") || this.getLocationMultiaddr("udp6");
        }
        if (protocol === "tcp") {
            return this.getLocationMultiaddr("tcp4") || this.getLocationMultiaddr("tcp6");
        }
        if (protocol === "quic") {
            return this.getLocationMultiaddr("quic4") || this.getLocationMultiaddr("quic6");
        }
        const isIpv6 = protocol.endsWith("6");
        const ipVal = this.kvs.get(isIpv6 ? "ip6" : "ip");
        if (!ipVal) {
            return undefined;
        }
        const isUdp = protocol.startsWith("udp");
        const isTcp = protocol.startsWith("tcp");
        const isQuic = protocol.startsWith("quic");
        let protoName, protoVal;
        if (isUdp) {
            protoName = "udp";
            protoVal = isIpv6 ? this.kvs.get("udp6") : this.kvs.get("udp");
        }
        else if (isTcp) {
            protoName = "tcp";
            protoVal = isIpv6 ? this.kvs.get("tcp6") : this.kvs.get("tcp");
        }
        else if (isQuic) {
            protoName = "udp";
            protoVal = isIpv6 ? this.kvs.get("quic6") : this.kvs.get("quic");
        }
        else {
            return undefined;
        }
        if (!protoVal) {
            return undefined;
        }
        // Create raw multiaddr buffer
        // multiaddr length is:
        //  1 byte for the ip protocol (ip4 or ip6)
        //  N bytes for the ip address
        //  1 or 2 bytes for the protocol as buffer (tcp or udp)
        //  2 bytes for the port
        const ipMa = protocols(isIpv6 ? "ip6" : "ip4");
        const ipByteLen = ipMa.size / 8;
        const protoMa = protocols(protoName);
        const protoBuf = varintEncode(protoMa.code);
        const maBuf = new Uint8Array(3 + ipByteLen + protoBuf.length);
        maBuf[0] = ipMa.code;
        maBuf.set(ipVal, 1);
        maBuf.set(protoBuf, 1 + ipByteLen);
        maBuf.set(protoVal, 1 + ipByteLen + protoBuf.length);
        const ma = multiaddr(maBuf);
        if (isQuic) {
            return ma.encapsulate("/quic-v1");
        }
        return ma;
    }
    async getFullMultiaddr(protocol) {
        const locationMultiaddr = this.getLocationMultiaddr(protocol);
        if (locationMultiaddr) {
            const peerId = this.peerId;
            return locationMultiaddr.encapsulate(`/p2p/${peerId.toString()}`);
        }
    }
    encodeTxt() {
        return "enr:" + toBase64url(this.encode());
    }
}
/**
 * Ethereum Name Record
 *
 * https://eips.ethereum.org/EIPS/eip-778
 *
 * `ENR` is used to read serialized ENRs and may not be modified once created.
 */
export class ENR extends BaseENR {
    kvs;
    seq;
    signature;
    nodeId;
    encoded;
    constructor(kvs, seq, signature, encoded) {
        super();
        this.kvs = new Map(kvs instanceof Map ? kvs.entries() : Object.entries(kvs));
        this.seq = seq;
        this.signature = signature;
        this.nodeId = nodeId(this.id, this.publicKey);
        this.encoded = encoded;
    }
    static fromObject(obj) {
        return new ENR(obj.kvs, obj.seq, obj.signature);
    }
    static decodeFromValues(encoded) {
        const { kvs, seq, signature } = decodeFromValues(encoded);
        return new ENR(kvs, seq, signature);
    }
    static decode(encoded) {
        const { kvs, seq, signature } = decode(encoded);
        return new ENR(kvs, seq, signature, encoded);
    }
    static decodeTxt(encoded) {
        const encodedBuf = txtToBuf(encoded);
        const { kvs, seq, signature } = decode(encodedBuf);
        return new ENR(kvs, seq, signature, encodedBuf);
    }
    get publicKey() {
        return publicKey(this.id, this.kvs);
    }
    toObject() {
        return {
            kvs: this.kvs,
            seq: this.seq,
            signature: this.signature,
        };
    }
    encodeToValues() {
        return RLP.decode(this.encode());
    }
    encode() {
        if (!this.encoded) {
            this.encoded = encode(this.kvs, this.seq, this.signature);
        }
        return this.encoded;
    }
}
/**
 * Ethereum Name Record
 *
 * https://eips.ethereum.org/EIPS/eip-778
 *
 * `SignableENR` is used to create and update ENRs.
 */
export class SignableENR extends BaseENR {
    kvs;
    seq;
    nodeId;
    publicKey;
    privateKey;
    _signature;
    constructor(kvs = {}, seq = 1n, privateKey, signature) {
        super();
        this.kvs = new Map(kvs instanceof Map ? kvs.entries() : Object.entries(kvs));
        this.seq = seq;
        this.privateKey = privateKey;
        this.publicKey = publicKey(this.id, this.kvs);
        this.nodeId = nodeId(this.id, this.publicKey);
        this._signature = signature;
        if (this.id === IDScheme.v4) {
            if (compare(getV4Crypto().publicKey(this.privateKey), this.publicKey) !== 0) {
                throw new Error("Provided keypair doesn't match kv pubkey");
            }
        }
    }
    static fromObject(obj) {
        const _id = id(obj.kvs);
        return new SignableENR(obj.kvs, obj.seq, obj.privateKey);
    }
    static createV4(privateKey, kvs = {}) {
        return new SignableENR({
            ...kvs,
            id: fromString("v4"),
            secp256k1: getV4Crypto().publicKey(privateKey),
        }, BigInt(1), privateKey);
    }
    static createFromPrivateKey(privateKey, kvs = {}) {
        switch (privateKey.type) {
            case "secp256k1":
                return SignableENR.createV4(privateKey.raw, kvs);
            default:
                throw new Error();
        }
    }
    static decodeFromValues(encoded, privateKey) {
        const { kvs, seq, signature } = decodeFromValues(encoded);
        return new SignableENR(kvs, seq, privateKey, signature);
    }
    static decode(encoded, privateKey) {
        const { kvs, seq, signature } = decode(encoded);
        return new SignableENR(kvs, seq, privateKey, signature);
    }
    static decodeTxt(encoded, privateKey) {
        const { kvs, seq, signature } = decodeTxt(encoded);
        return new SignableENR(kvs, seq, privateKey, signature);
    }
    get signature() {
        if (!this._signature) {
            this._signature = sign(this.id, RLP.encode(encodeToValues(this.kvs, this.seq)), this.privateKey);
        }
        return this._signature;
    }
    set(k, v) {
        if (k === "secp256k1" && this.id === "v4") {
            throw new Error("Unable to update `secp256k1` value");
        }
        // cache invalidation on any mutation
        this._signature = undefined;
        this.seq++;
        this.kvs.set(k, v);
    }
    delete(k) {
        if (k === "secp256k1" && this.id === "v4") {
            throw new Error("Unable to update `secp256k1` value");
        }
        // cache invalidation on any mutation
        this._signature = undefined;
        this.seq++;
        return this.kvs.delete(k);
    }
    // Identity methods
    get peerId() {
        return createPeerIdFromPublicKey(this.keypairType, this.publicKey);
    }
    // Network methods
    get ip() {
        return getIPValue(this.kvs, "ip", "ip4");
    }
    set ip(ip) {
        if (ip) {
            this.set("ip", convertToBytes("ip4", ip));
        }
        else {
            this.delete("ip");
        }
    }
    get tcp() {
        return getProtocolValue(this.kvs, "tcp");
    }
    set tcp(port) {
        if (port === undefined) {
            this.delete("tcp");
        }
        else {
            this.set("tcp", portToBuf(port));
        }
    }
    get udp() {
        return getProtocolValue(this.kvs, "udp");
    }
    set udp(port) {
        if (port === undefined) {
            this.delete("udp");
        }
        else {
            this.set("udp", portToBuf(port));
        }
    }
    get quic() {
        return getProtocolValue(this.kvs, "quic");
    }
    set quic(port) {
        if (port === undefined) {
            this.delete("quic");
        }
        else {
            this.set("quic", portToBuf(port));
        }
    }
    get ip6() {
        return getIPValue(this.kvs, "ip6", "ip6");
    }
    set ip6(ip) {
        if (ip) {
            this.set("ip6", convertToBytes("ip6", ip));
        }
        else {
            this.delete("ip6");
        }
    }
    get tcp6() {
        return getProtocolValue(this.kvs, "tcp6");
    }
    set tcp6(port) {
        if (port === undefined) {
            this.delete("tcp6");
        }
        else {
            this.set("tcp6", portToBuf(port));
        }
    }
    get udp6() {
        return getProtocolValue(this.kvs, "udp6");
    }
    set udp6(port) {
        if (port === undefined) {
            this.delete("udp6");
        }
        else {
            this.set("udp6", portToBuf(port));
        }
    }
    get quic6() {
        return getProtocolValue(this.kvs, "quic6");
    }
    set quic6(port) {
        if (port === undefined) {
            this.delete("quic6");
        }
        else {
            this.set("quic6", portToBuf(port));
        }
    }
    setLocationMultiaddr(multiaddr) {
        const { family, ip, protoName, protoVal } = parseLocationMultiaddr(multiaddr);
        if (family === 4) {
            this.set("ip", ip);
            this.set(protoName, protoVal);
        }
        else {
            this.set("ip6", ip);
            this.set(protoName + "6", protoVal);
        }
    }
    toObject() {
        return {
            kvs: this.kvs,
            seq: this.seq,
            privateKey: this.privateKey,
        };
    }
    encodeToValues() {
        return encodeToValues(this.kvs, this.seq, this.signature);
    }
    encode() {
        return encode(this.kvs, this.seq, this.signature);
    }
    toENR() {
        return new ENR(this.kvs, this.seq, this.signature, this.encode());
    }
}
//# sourceMappingURL=enr.js.map