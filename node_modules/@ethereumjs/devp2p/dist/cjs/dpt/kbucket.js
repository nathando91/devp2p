"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KBucket = void 0;
const util_1 = require("@ethereumjs/util");
const eventemitter3_1 = require("eventemitter3");
const index_ts_1 = require("../ext/index.js");
const KBUCKET_SIZE = 16;
const KBUCKET_CONCURRENCY = 3;
class KBucket {
    constructor(localNodeId) {
        this._peers = new Map();
        this.events = new eventemitter3_1.EventEmitter();
        this._kbucket = new index_ts_1.KBucket({
            localNodeId,
            numberOfNodesPerKBucket: KBUCKET_SIZE,
            numberOfNodesToPing: KBUCKET_CONCURRENCY,
        });
        this._kbucket.events.on('added', (peer) => {
            for (const key of KBucket.getKeys(peer)) {
                this._peers.set(key, peer);
            }
            this.events.emit('added', peer);
        });
        this._kbucket.events.on('removed', (peer) => {
            for (const key of KBucket.getKeys(peer)) {
                this._peers.delete(key);
            }
            this.events.emit('removed', peer);
        });
        this._kbucket.events.on('ping', (oldPeers, newPeer) => {
            this.events.emit('ping', oldPeers, newPeer);
        });
    }
    static getKeys(obj) {
        if (obj instanceof Uint8Array)
            return [(0, util_1.bytesToUnprefixedHex)(obj)];
        if (typeof obj === 'string')
            return [obj];
        const keys = [];
        if (obj.id instanceof Uint8Array)
            keys.push((0, util_1.bytesToUnprefixedHex)(obj.id));
        if (obj.address !== undefined && typeof obj.tcpPort === 'number')
            keys.push(`${obj.address}:${obj.tcpPort}`);
        return keys;
    }
    add(peer) {
        const isExists = KBucket.getKeys(peer).some((key) => this._peers.has(key));
        if (!isExists)
            this._kbucket.add(peer);
    }
    get(obj) {
        for (const key of KBucket.getKeys(obj)) {
            const peer = this._peers.get(key);
            if (peer !== undefined)
                return peer;
        }
        return null;
    }
    getAll() {
        return this._kbucket.toArray();
    }
    closest(id) {
        return this._kbucket.closest(id, KBUCKET_SIZE);
    }
    remove(obj) {
        const peer = this.get(obj);
        if (peer?.id !== undefined)
            this._kbucket.remove(peer.id);
    }
}
exports.KBucket = KBucket;
//# sourceMappingURL=kbucket.js.map